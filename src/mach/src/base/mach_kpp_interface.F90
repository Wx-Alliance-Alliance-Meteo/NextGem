!---------------------------------- licence begin -------------------------------
! gem-mach - atmospheric chemistry library for the gem numerical atmospheric model
! copyright (c) 2007-2013 - air quality research division &
!                           national prediction operations division
!                           environnement canada
! this library is free software; you can redistribute it and/or
! modify it under the terms of the gnu lesser general public
! license as published by the free software foundation; either
! version 2.1 of the license, or (at your option) any later version.
!
! this library is distributed in the hope that it will be useful,
! but without any warranty; without even the implied warranty of
! merchantability or fitness for a particular purpose.  see the gnu
! lesser general public license for more details.
!
! you should have received a copy of the gnu lesser general public
! license along with this library; if not, write to the free software
! foundation, inc., 51 franklin street, fifth floor, boston, ma  02110-1301  usa
!---------------------------------- licence end ---------------------------------
!============================================================================!
!         environnement canada         |        environment canada           !
!                                      |                                     !
! - service meteorologique du canada   | - meteorological service of canada  !
! - direction generale des sciences    | - science and technology branch     !
!   et de la technologie               |                                     !
!============================================================================!
!                            http://www.ec.gc.ca                             !
!============================================================================!
!
! projet/project : gem-mach
! fichier/file   : mach_kpp_interface.ftn90
! creation       : Jack Chen - 2017-Jan
!
! description    : entry point for gasphase chemistry solver-interface routine
!                  for solver code generated by KPP
!
! code history   : - scalar vs. grided hstart
!
!
! argument:
!        intent in:
!                       rxt1d   - reaction rates
!                       ATOL    - Absolute tolerance
!                       RTOL    - Relative tolerance
!                       itolctr - Scalar or vector tolerance control
!        intent in/out:
!                       conc    - concentration for all species
!                       hstart  - Internal time-step (scalar)

!!if_on
 subroutine mach_kpp_interface(conc, rxt1d, atol, rtol, shstart, itolctr)
   use mach_pkg_gas_mod,    only: nspec, nreact, nvar
!!if_off
   use chm_utils_mod,       only: chm_lun_out, global_debug, &
                                  chm_timestep, chm_error_l
   use mach_gas_headers_mod,only: mach_kpp_integrator
   use mach_pkg_gas_mod,    only: nfix, minkppconc
   use mach_gas_headers_mod, only: mach_kpp_integrator

   IMPLICIT NONE

!!if_on
   real(kind=8),    intent(inout) :: conc (nspec) ! concentration for all species
   real(kind=8),    intent(in)    :: rxt1d(nreact) ! reaction rate
   real(kind=8),    intent(in)    :: atol (nvar)
   real(kind=8),    intent(in)    :: rtol (nvar)
   real(kind=8),    intent(inout) :: shstart
   integer(kind=4), intent(in)    :: itolctr
!!if_off

! local variables
! VAR - Concentration of variable species
   real(kind=8) :: VAR(NVAR)
! FIX - Concentration of fix species
   real(kind=8) :: FIX(NFIX)
! TSTART - Integration start time
   real(kind=8) :: TSTART
! TEND - Integration end time
   real(kind=8) :: TEND
   real(kind=8) :: delt

   real(kind=8)   :: RCNTRL(20), RSTATUS(20)
   integer(kind=4) :: ICNTRL(20), ISTATUS(20), IERR
   integer(kind=4), parameter :: Nhnew = 3  ! copied from the KPP_integrator module

   real(kind=8), parameter :: ZERO = 0.0d0  ! for setting default
   logical(kind=4) :: local_dbg

!!----------- BEGIN CODE  --------------
   local_dbg = ((.false. .or. global_debug) .and. (chm_lun_out > 0))

!-- set solver input parameters
   delt = dble(chm_timestep)
   TSTART  = 0.0d0
   TEND = TSTART + delt

   !~~~> fine-tune the integrator flag (0=default)
   ICNTRL(1) = 1  ! 0 - non-autonomous (Time dependent), 1 - autonomous dy/dt = F(y)
   ICNTRL(2) = itolctr  ! 0 - vector tolerances, 1 - scalars
   ICNTRL(3) = 0  ! Rodas3 method; !  -> selection of a particular Rosenbrock method
   !        = 0 :    Rodas3 (default)
   !        = 1 :    Ros2
   !        = 2 :    Ros3
   !        = 3 :    Ros4
   !        = 4 :    Rodas3
   !        = 5 :    Rodas4
   !        = 6 :    Rang3
   ICNTRL(4) = 0  ! max. integration step (default=100000)
   ICNTRL(5:20) = 0  ! all default

!    if (local_dbg ) then
!       write(chm_lun_out, *) "==============================================="
!       write(chm_lun_out, *) "inside mach_kpp_interface"
!       write(chm_lun_out, *) "KPP ROSENBROCK solver control flags"
!       write(chm_lun_out, *) "ICNTRL(3) 1- Ros2 ; 2-Ros3 ; 3-Ros4 ; 0/4-Rodas3 ; 5-Rodas4 ; 6-Rang3"
!       write(chm_lun_out, *) "ICNTRL(3)=:",ICNTRL(3)
!       write(chm_lun_out, *) "Absolute/Relative tolerance: ",ATOL(1),RTOL(1)
!       write(chm_lun_out, *) "Scalar Hstart: ",shstart
!       write(chm_lun_out, *) "==============================================="
!    end if

   !~~~> fine-tune the integrator timing (ZERO=default)
   RCNTRL(1) = ZERO  ! Hmin minimum integration step size
   RCNTRL(2) = ZERO  ! Hmax maximum integration step size (default=delT)
   RCNTRL(3) = shstart ! scalar hstart
   RCNTRL(4) = ZERO  ! minimum step decrease factor (default=0.2)
   RCNTRL(5) = ZERO  ! maximum step increase factor (default=6)
   RCNTRL(6) = ZERO  ! step decrease factor after rejections (default=0.1)
   RCNTRL(7) = ZERO  ! new setp is smaller than predicted value (default=0.9)
   RCNTRL(8:20) = ZERO  ! all default

   VAR(1:NVAR) = max(CONC(1:NVAR), minkppconc)
   FIX(1:NFIX) = CONC(NVAR+1:NSPEC)  ! fill KPP module variable

 ! initialize return values
   ISTATUS = 0
   RSTATUS = 0.0
   IERR = -1

   call mach_kpp_integrator( NVAR, VAR, TSTART, TEND, ATOL, RTOL, FIX, &
                             RXT1D, RCNTRL, ICNTRL, RSTATUS, ISTATUS, IERR )

   if (IERR < 0) then
      write(*, *) 'Error with KPP ROSENBROCK solver IERR=',IERR
      write(*, *) 'RTOL:', RTOL(1)
      write(*, *) 'VAR:', VAR
      write(*, *) 'FIX:', FIX
      write(*, *) 'RXD:',RXT1D(1:NREACT)
      write(*, *) 'INPUT CONC:', CONC(1:NVAR)
      write (*, 1111) 'IERR, ISTATUS(1:8): ',IERR, ISTATUS(1:8)
      write (*, *) 'ISTATUS(1) # Fn calls:',ISTATUS(1)
      write (*, *) 'ISTATUS(2) # Jc calls:',ISTATUS(2)
      write (*, *) 'ISTATUS(3) #    steps:',ISTATUS(3)
      write (*, *) 'ISTATUS(4) # acpt stp:',ISTATUS(4)
      write (*, *) 'RSTATUS(1) exit time:',RSTATUS(1)
      write (*, *) 'RSTATUS(2) last time:',RSTATUS(2)
      write (*, *) 'RSTATUS(3) next time:',RSTATUS(3)
 1111 format(a, 10(i5))
      write(*, *) 'Retry with RCNTRL(:) = default'
      VAR(1:NVAR) = max(CONC(1:NVAR), minkppconc)
      FIX(1:NFIX) = CONC(NVAR+1:NSPEC)  ! fill KPP module variable
      RCNTRL(1:20) = ZERO
      call mach_kpp_integrator(NVAR, VAR, TSTART, TEND, ATOL, RTOL, FIX, &
                               RXT1D, RCNTRL, ICNTRL, RSTATUS, ISTATUS, IERR)
      if (IERR < 0) then
          write(*, *) 'Error with retry KPP solver IERR=',IERR
          write (*, 1111) 'IERR, ISTATUS(1:8): ',IERR, ISTATUS(1:8)
          write(*, *) 'RTOL:', RTOL(1)
          write(*, *) 'VAR:', VAR
          write(*, *) 'FIX:', FIX
          write(*, *) 'RXD:',RXT1D(1:NREACT)
          write(*, *) 'INPUT CONC:', CONC(1:NVAR)
          chm_error_l = .true.
          return
      end if
   end if

   CONC(1:NVAR) = VAR(1:NVAR)

   shstart = RSTATUS(Nhnew) ! new start iteration time

   return
 end subroutine mach_kpp_interface
